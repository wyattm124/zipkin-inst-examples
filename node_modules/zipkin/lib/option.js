"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isOptional = isOptional;
exports.verifyIsOptional = verifyIsOptional;
exports.verifyIsNotOptional = verifyIsNotOptional;
exports.fromNullable = fromNullable;
exports.Some = exports.None = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var None = {
  get type() {
    return 'None';
  },

  get present() {
    return false;
  },

  map: function map() {
    return this;
  },
  ifPresent: function ifPresent() {},
  flatMap: function flatMap() {
    return this;
  },
  getOrElse: function getOrElse(f) {
    return f instanceof Function ? f() : f;
  },
  equals: function equals(other) {
    return other === this;
  },
  toString: function toString() {
    return 'None';
  }
};
exports.None = None;

var Some =
/*#__PURE__*/
function () {
  function Some(value) {
    _classCallCheck(this, Some);

    this.value = value;
  }

  _createClass(Some, [{
    key: "map",
    value: function map(f) {
      return new Some(f(this.value));
    }
  }, {
    key: "ifPresent",
    value: function ifPresent(f) {
      f(this.value);
    }
  }, {
    key: "flatMap",
    value: function flatMap(f) {
      return f(this.value);
    }
  }, {
    key: "getOrElse",
    value: function getOrElse() {
      return this.value;
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return other instanceof Some && other.value === this.value;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Some(".concat(this.value, ")");
    }
  }, {
    key: "type",
    get: function get() {
      return 'Some';
    }
  }, {
    key: "present",
    get: function get() {
      return true;
    }
  }]);

  return Some;
}(); // Used to validate input arguments


exports.Some = Some;

function isOptional(data) {
  return data instanceof Some || None.equals(data);
}

function verifyIsOptional(data) {
  if (data == null) {
    throw new Error('Error: data is not Optional - it\'s null');
  }

  if (isOptional(data)) {
    if (isOptional(data.value)) {
      throw new Error("Error: data (".concat(data.value, ") is wrapped in Option twice"));
    }
  } else {
    throw new Error("Error: data (".concat(data, ") is not an Option!"));
  }
}

function verifyIsNotOptional(data) {
  if (isOptional(data)) {
    throw new Error("Error: data (".concat(data, ") is an Option!"));
  }
}

function fromNullable(nullable) {
  return nullable == null ? None : new Some(nullable);
}