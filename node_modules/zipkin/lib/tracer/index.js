"use strict";

var _option = require("../option");

var _sampler = require("./sampler");

var _annotation = _interopRequireDefault(require("../annotation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Record = require('./record');

var TraceId = require('./TraceId');

var randomTraceId = require('./randomTraceId');

var _require = require('../time'),
    now = _require.now,
    hrtime = _require.hrtime;

var _require2 = require('../model'),
    Endpoint = _require2.Endpoint;

var isPromise = require('is-promise');

function requiredArg(name) {
  throw new Error("Tracer: Missing required argument ".concat(name, "."));
}

var Tracer =
/*#__PURE__*/
function () {
  function Tracer(_ref) {
    var _ref$ctxImpl = _ref.ctxImpl,
        ctxImpl = _ref$ctxImpl === void 0 ? requiredArg('ctxImpl') : _ref$ctxImpl,
        _ref$recorder = _ref.recorder,
        recorder = _ref$recorder === void 0 ? requiredArg('recorder') : _ref$recorder,
        _ref$sampler = _ref.sampler,
        sampler = _ref$sampler === void 0 ? new _sampler.Sampler(_sampler.alwaysSample) : _ref$sampler,
        _ref$traceId128Bit = _ref.traceId128Bit,
        traceId128Bit = _ref$traceId128Bit === void 0 ? false : _ref$traceId128Bit,
        _ref$supportsJoin = _ref.supportsJoin,
        supportsJoin = _ref$supportsJoin === void 0 ? true : _ref$supportsJoin,
        localServiceName = _ref.localServiceName,
        localEndpoint = _ref.localEndpoint,
        _ref$log = _ref.log,
        log = _ref$log === void 0 ? console : _ref$log;

    _classCallCheck(this, Tracer);

    this.log = log;
    this.recorder = recorder;
    this.sampler = sampler;
    this.traceId128Bit = traceId128Bit;
    this.supportsJoin = supportsJoin;

    if (localEndpoint) {
      this._localEndpoint = localEndpoint;
    } else {
      this._localEndpoint = new Endpoint({
        serviceName: localServiceName || 'unknown'
      });
    }

    this._ctxImpl = ctxImpl;
    this._defaultTraceId = this.createRootId();
    this._startTimestamp = now();
    this._startTick = hrtime();
  }

  _createClass(Tracer, [{
    key: "scoped",
    value: function scoped(callback) {
      return this._ctxImpl.scoped(callback);
    }
  }, {
    key: "letId",
    value: function letId(id, callback) {
      return this._ctxImpl.letContext(id, callback);
    }
  }, {
    key: "createRootId",
    value: function createRootId() {
      var isSampled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _option.None;
      var isDebug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rootSpanId = randomTraceId();
      var traceId = this.traceId128Bit ? new _option.Some(randomTraceId() + rootSpanId) : _option.None;
      var id = new TraceId({
        traceId: traceId,
        parentId: _option.None,
        spanId: rootSpanId,
        sampled: isSampled,
        flags: isDebug ? 1 : 0
      });

      if (isSampled === _option.None) {
        id._sampled = this.sampler.shouldSample(id);
      }

      return id;
    }
  }, {
    key: "createChildId",
    value: function createChildId() {
      var currentId = (0, _option.fromNullable)(this._ctxImpl.getContext());
      var childId = new TraceId({
        traceId: currentId.map(function (id) {
          return id.traceId;
        }),
        parentId: currentId.map(function (id) {
          return id.spanId;
        }),
        spanId: randomTraceId(),
        sampled: currentId.flatMap(function (id) {
          return id.sampled;
        }),
        flags: currentId.map(function (id) {
          return id.flags;
        }).getOrElse(0)
      });

      if (childId.sampled.present === false) {
        childId._sampled = this.sampler.shouldSample(childId);
      }

      return childId;
    } // creates a span, timing the given callable, adding any error as a tag
    // if the callable returns a promise, a span stops after the promise resolves

  }, {
    key: "local",
    value: function local(operationName, callable) {
      var _this = this;

      if (typeof callable !== 'function') {
        throw new Error('you must pass a function');
      }

      return this.scoped(function () {
        var traceId = _this.createChildId();

        _this.setId(traceId);

        _this.recordServiceName(_this._localEndpoint.serviceName);

        _this.recordAnnotation(new _annotation.default.LocalOperationStart(operationName));

        var result;

        try {
          result = callable();
        } catch (err) {
          _this.recordBinary('error', err.message ? err.message : err.toString());

          _this.recordAnnotation(new _annotation.default.LocalOperationStop());

          throw err;
        } // Finish the span on a synchronous success


        if (!isPromise(result)) {
          _this.recordAnnotation(new _annotation.default.LocalOperationStop());

          return result;
        }

        if (!traceId.sampled.getOrElse(false)) {
          return result; // no need to stop as it was never started
        } // At this point we know we are sampled. Explicitly record against the ID


        var explicitRecord = function explicitRecord(annotation) {
          return _this.recorder.record(new Record({
            traceId: traceId,
            timestamp: now(_this._startTimestamp, _this._startTick),
            annotation: annotation
          }));
        }; // Ensure the span representing the promise completes


        return result.then(function (output) {
          explicitRecord(new _annotation.default.LocalOperationStop());
          return output;
        }).catch(function (err) {
          var message = err.message ? err.message : err.toString();
          explicitRecord(new _annotation.default.BinaryAnnotation('error', message));
          explicitRecord(new _annotation.default.LocalOperationStop());
          throw err;
        });
      });
    }
  }, {
    key: "setId",
    value: function setId(traceId) {
      this._ctxImpl.setContext(traceId);
    }
  }, {
    key: "recordAnnotation",
    value: function recordAnnotation(annotation) {
      var _this2 = this;

      var timestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : now(this._startTimestamp, this._startTick);
      this.id.sampled.ifPresent(function (sampled) {
        if (!sampled) {
          return;
        }

        _this2.recorder.record(new Record({
          annotation: annotation,
          timestamp: timestamp,
          traceId: _this2.id
        }));
      });
    }
  }, {
    key: "recordMessage",
    value: function recordMessage(message) {
      this.recordAnnotation(new _annotation.default.Message(message));
    }
  }, {
    key: "recordServiceName",
    value: function recordServiceName(serviceName) {
      this.recordAnnotation(new _annotation.default.ServiceName(serviceName));
    }
  }, {
    key: "recordRpc",
    value: function recordRpc(name) {
      this.recordAnnotation(new _annotation.default.Rpc(name));
    }
  }, {
    key: "recordClientAddr",
    value: function recordClientAddr(ia) {
      this.recordAnnotation(new _annotation.default.ClientAddr(ia));
    }
  }, {
    key: "recordServerAddr",
    value: function recordServerAddr(ia) {
      this.recordAnnotation(new _annotation.default.ServerAddr(ia));
    }
  }, {
    key: "recordLocalAddr",
    value: function recordLocalAddr(ia) {
      this.recordAnnotation(new _annotation.default.LocalAddr(ia));
    }
  }, {
    key: "recordBinary",
    value: function recordBinary(key, value) {
      this.recordAnnotation(new _annotation.default.BinaryAnnotation(key, value));
    }
  }, {
    key: "writeIdToConsole",
    value: function writeIdToConsole(message) {
      this.log.info("".concat(message, ": ").concat(this.id.toString()));
    }
  }, {
    key: "setTags",
    value: function setTags() {
      var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // eslint-disable-next-line no-restricted-syntax
      for (var tag in tags) {
        if (tags.hasOwnProperty(tag)) {
          this.recordBinary(tag, tags[tag]);
        }
      }
    }
  }, {
    key: "id",
    get: function get() {
      return this._ctxImpl.getContext() || this._defaultTraceId;
    }
  }, {
    key: "localEndpoint",
    get: function get() {
      return this._localEndpoint;
    }
  }]);

  return Tracer;
}();

module.exports = Tracer;