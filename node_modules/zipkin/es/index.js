import os from 'os';
import url from 'url';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

var None = {
  get type() {
    return 'None';
  },

  get present() {
    return false;
  },

  map: function map() {
    return this;
  },
  ifPresent: function ifPresent() {},
  flatMap: function flatMap() {
    return this;
  },
  getOrElse: function getOrElse(f) {
    return f instanceof Function ? f() : f;
  },
  equals: function equals(other) {
    return other === this;
  },
  toString: function toString() {
    return 'None';
  }
};

var Some =
/*#__PURE__*/
function () {
  function Some(value) {
    _classCallCheck(this, Some);

    this.value = value;
  }

  _createClass(Some, [{
    key: "map",
    value: function map(f) {
      return new Some(f(this.value));
    }
  }, {
    key: "ifPresent",
    value: function ifPresent(f) {
      f(this.value);
    }
  }, {
    key: "flatMap",
    value: function flatMap(f) {
      return f(this.value);
    }
  }, {
    key: "getOrElse",
    value: function getOrElse() {
      return this.value;
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return other instanceof Some && other.value === this.value;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Some(".concat(this.value, ")");
    }
  }, {
    key: "type",
    get: function get() {
      return 'Some';
    }
  }, {
    key: "present",
    get: function get() {
      return true;
    }
  }]);

  return Some;
}(); // Used to validate input arguments


function isOptional(data) {
  return data instanceof Some || None.equals(data);
}

function verifyIsOptional(data) {
  if (data == null) {
    throw new Error('Error: data is not Optional - it\'s null');
  }

  if (isOptional(data)) {
    if (isOptional(data.value)) {
      throw new Error("Error: data (".concat(data.value, ") is wrapped in Option twice"));
    }
  } else {
    throw new Error("Error: data (".concat(data, ") is not an Option!"));
  }
}

function verifyIsNotOptional(data) {
  if (isOptional(data)) {
    throw new Error("Error: data (".concat(data, ") is an Option!"));
  }
}

function fromNullable(nullable) {
  return nullable == null ? None : new Some(nullable);
}

var Some_1 = Some;
var None_1 = None;
var isOptional_1 = isOptional;
var verifyIsOptional_1 = verifyIsOptional;
var verifyIsNotOptional_1 = verifyIsNotOptional;
var fromNullable_1 = fromNullable;
var option = {
  Some: Some_1,
  None: None_1,
  isOptional: isOptional_1,
  verifyIsOptional: verifyIsOptional_1,
  verifyIsNotOptional: verifyIsNotOptional_1,
  fromNullable: fromNullable_1
};

function pickInterface(interfaces, family) {
  /*eslint-disable */
  for (var i in interfaces) {
    /*eslint-enable */
    for (var j = interfaces[i].length - 1; j >= 0; j--) {
      var face = interfaces[i][j];
      var reachable = family === 'IPv4' || face.scopeid === 0;
      if (!face.internal && face.family === family && reachable) return face.address;
    }
  }

  return family === 'IPv4' ? '127.0.0.1' : '::1';
}

function reduceInterfaces(interfaces, iface) {
  var ifaces = {};
  /*eslint-disable */

  for (var i in interfaces) {
    /*eslint-enable */
    if (i === iface) ifaces[i] = interfaces[i];
  }

  return ifaces;
}

function ipv4(iface) {
  var interfaces = os.networkInterfaces();
  if (iface) interfaces = reduceInterfaces(interfaces, iface);
  return pickInterface(interfaces, 'IPv4');
}

function ipv6(iface) {
  var interfaces = os.networkInterfaces();
  if (iface) interfaces = reduceInterfaces(interfaces, iface);
  return pickInterface(interfaces, 'IPv6');
}

ipv4.ipv4 = ipv4;
ipv4.ipv6 = ipv6;
var network = ipv4;

var InetAddress =
/*#__PURE__*/
function () {
  function InetAddress(addr) {
    _classCallCheck(this, InetAddress);

    this.addr = addr;
  } // returns undefined if this isn't an IPv4 string


  _createClass(InetAddress, [{
    key: "ipv4",
    value: function ipv4() {
      // coercing to int forces validation here
      var ipv4Int = this.toInt();

      if (ipv4Int && ipv4Int !== 0) {
        return this.addr;
      }

      return undefined;
    }
  }, {
    key: "toInt",
    value: function toInt() {
      // e.g. 10.57.50.83
      // should become
      // 171520595
      var parts = this.addr.split('.'); // The jshint tool always complains about using bitwise operators,
      // but in this case it's actually intentional, so we disable the warning:
      // jshint bitwise: false

      return parts[0] << 24 | parts[1] << 16 | parts[2] << 8 | parts[3];
    }
  }, {
    key: "toString",
    value: function toString() {
      return "InetAddress(".concat(this.addr, ")");
    }
  }]);

  return InetAddress;
}(); // In non-node environments we fallback to 127.0.0.1


InetAddress.getLocalAddress = function getLocalAddress() {
  var isNode = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && typeof process.on === 'function';

  if (!isNode) {
    return new InetAddress('127.0.0.1');
  } // eslint-disable-next-line global-require


  var networkAddress = network;
  return new InetAddress(networkAddress.ipv4());
};

var InetAddress_1 = InetAddress;

var SimpleAnnotation =
/*#__PURE__*/
function () {
  function SimpleAnnotation() {
    _classCallCheck(this, SimpleAnnotation);
  }

  _createClass(SimpleAnnotation, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.annotationType, "()");
    }
  }]);

  return SimpleAnnotation;
}();

var ClientSend =
/*#__PURE__*/
function (_SimpleAnnotation) {
  _inherits(ClientSend, _SimpleAnnotation);

  function ClientSend() {
    _classCallCheck(this, ClientSend);

    return _possibleConstructorReturn(this, _getPrototypeOf(ClientSend).apply(this, arguments));
  }

  return ClientSend;
}(SimpleAnnotation);

var ClientRecv =
/*#__PURE__*/
function (_SimpleAnnotation2) {
  _inherits(ClientRecv, _SimpleAnnotation2);

  function ClientRecv() {
    _classCallCheck(this, ClientRecv);

    return _possibleConstructorReturn(this, _getPrototypeOf(ClientRecv).apply(this, arguments));
  }

  return ClientRecv;
}(SimpleAnnotation);

var ServerSend =
/*#__PURE__*/
function (_SimpleAnnotation3) {
  _inherits(ServerSend, _SimpleAnnotation3);

  function ServerSend() {
    _classCallCheck(this, ServerSend);

    return _possibleConstructorReturn(this, _getPrototypeOf(ServerSend).apply(this, arguments));
  }

  return ServerSend;
}(SimpleAnnotation);

var ServerRecv =
/*#__PURE__*/
function (_SimpleAnnotation4) {
  _inherits(ServerRecv, _SimpleAnnotation4);

  function ServerRecv() {
    _classCallCheck(this, ServerRecv);

    return _possibleConstructorReturn(this, _getPrototypeOf(ServerRecv).apply(this, arguments));
  }

  return ServerRecv;
}(SimpleAnnotation);

var ProducerStart =
/*#__PURE__*/
function (_SimpleAnnotation5) {
  _inherits(ProducerStart, _SimpleAnnotation5);

  function ProducerStart() {
    _classCallCheck(this, ProducerStart);

    return _possibleConstructorReturn(this, _getPrototypeOf(ProducerStart).apply(this, arguments));
  }

  return ProducerStart;
}(SimpleAnnotation);

var ProducerStop =
/*#__PURE__*/
function (_SimpleAnnotation6) {
  _inherits(ProducerStop, _SimpleAnnotation6);

  function ProducerStop() {
    _classCallCheck(this, ProducerStop);

    return _possibleConstructorReturn(this, _getPrototypeOf(ProducerStop).apply(this, arguments));
  }

  return ProducerStop;
}(SimpleAnnotation);

var ConsumerStart =
/*#__PURE__*/
function (_SimpleAnnotation7) {
  _inherits(ConsumerStart, _SimpleAnnotation7);

  function ConsumerStart() {
    _classCallCheck(this, ConsumerStart);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConsumerStart).apply(this, arguments));
  }

  return ConsumerStart;
}(SimpleAnnotation);

var ConsumerStop =
/*#__PURE__*/
function (_SimpleAnnotation8) {
  _inherits(ConsumerStop, _SimpleAnnotation8);

  function ConsumerStop() {
    _classCallCheck(this, ConsumerStop);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConsumerStop).apply(this, arguments));
  }

  return ConsumerStop;
}(SimpleAnnotation);

function LocalOperationStart(name) {
  this.name = name;
}

LocalOperationStart.prototype.toString = function () {
  return "LocalOperationStart(\"".concat(this.name, "\")");
};

var LocalOperationStop =
/*#__PURE__*/
function (_SimpleAnnotation9) {
  _inherits(LocalOperationStop, _SimpleAnnotation9);

  function LocalOperationStop() {
    _classCallCheck(this, LocalOperationStop);

    return _possibleConstructorReturn(this, _getPrototypeOf(LocalOperationStop).apply(this, arguments));
  }

  return LocalOperationStop;
}(SimpleAnnotation);

function Message(message) {
  this.message = message;
}

Message.prototype.toString = function () {
  return "Message(\"".concat(this.message, "\")");
};

function ServiceName(serviceName) {
  this.serviceName = serviceName;
}

ServiceName.prototype.toString = function () {
  return "ServiceName(\"".concat(this.serviceName, "\")");
};

function Rpc(name) {
  this.name = name;
}

Rpc.prototype.toString = function () {
  return "Rpc(\"".concat(this.name, "\")");
};

function ClientAddr(_ref) {
  var host = _ref.host,
      port = _ref.port;
  this.host = host;
  this.port = port;
}

ClientAddr.prototype.toString = function () {
  return "ClientAddr(host=\"".concat(this.host, "\", port=").concat(this.port, ")");
};

function ServerAddr(_ref2) {
  var serviceName = _ref2.serviceName,
      host = _ref2.host,
      port = _ref2.port;
  this.serviceName = serviceName;
  this.host = host || undefined;
  this.port = port || 0;
}

ServerAddr.prototype.toString = function () {
  return "ServerAddr(serviceName=\"".concat(this.serviceName, "\", host=\"").concat(this.host, "\", port=").concat(this.port, ")");
};

function LocalAddr(_ref3) {
  var host = _ref3.host,
      port = _ref3.port;
  this.host = host || InetAddress_1.getLocalAddress();
  this.port = port || 0;
}

LocalAddr.prototype.toString = function () {
  return "LocalAddr(host=\"".concat(this.host.toString(), "\", port=").concat(this.port, ")");
};

function MessageAddr(_ref4) {
  var serviceName = _ref4.serviceName,
      host = _ref4.host,
      port = _ref4.port;
  this.serviceName = serviceName;
  this.host = host;
  this.port = port;
}

MessageAddr.prototype.toString = function () {
  return "MessageAddr(serviceName=\"".concat(this.serviceName, "\", host=\"").concat(this.host, "\", port=").concat(this.port, ")");
};

function BinaryAnnotation(key, value) {
  this.key = key;
  this.value = value;
}

BinaryAnnotation.prototype.toString = function () {
  return "BinaryAnnotation(".concat(this.key, "=\"").concat(this.value, "\")");
};

var annotation = {
  ClientSend: ClientSend,
  ClientRecv: ClientRecv,
  ServerSend: ServerSend,
  ServerRecv: ServerRecv,
  ProducerStart: ProducerStart,
  ProducerStop: ProducerStop,
  ConsumerStart: ConsumerStart,
  ConsumerStop: ConsumerStop,
  MessageAddr: MessageAddr,
  Message: Message,
  ServiceName: ServiceName,
  Rpc: Rpc,
  ClientAddr: ClientAddr,
  ServerAddr: ServerAddr,
  LocalAddr: LocalAddr,
  BinaryAnnotation: BinaryAnnotation,
  LocalOperationStart: LocalOperationStart,
  LocalOperationStop: LocalOperationStop
};
Object.keys(annotation).forEach(function (key) {
  annotation[key].prototype.annotationType = key;
});
var annotation_1 = annotation;

var Some$1 = option.Some; // Determines whether or not a traceId should be sampled.
// If no sample decision is already made (by a debug flag, or
// the "sampled" property is set), it will use evaluator,
// which is a function traceId => Boolean, and returns true if
// the traceId should be sampled (stored in Zipkin).

var Sampler =
/*#__PURE__*/
function () {
  function Sampler(evaluator) {
    _classCallCheck(this, Sampler);

    this.evaluator = evaluator;
  }

  _createClass(Sampler, [{
    key: "shouldSample",
    value: function shouldSample(traceId) {
      var _this = this;

      var result = traceId.sampled.getOrElse(function () {
        return _this.evaluator(traceId);
      });
      return new Some$1(result);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Sampler(".concat(this.evaluator.toString(), ")");
    }
  }]);

  return Sampler;
}();

function neverSample(traceId) {
  // eslint-disable-line no-unused-vars
  return false;
}

neverSample.toString = function () {
  return 'never sample';
};

function alwaysSample(traceId) {
  // eslint-disable-line no-unused-vars
  return true;
}

alwaysSample.toString = function () {
  return 'always sample';
};

function makeCountingEvaluator(sampleRate) {
  if (sampleRate <= 0) {
    return neverSample;
  } else if (sampleRate >= 1) {
    return alwaysSample;
  } else {
    var counter = 0;
    var limit = parseInt(1 / sampleRate);

    var counting = function counting(traceId) {
      // eslint-disable-line no-unused-vars
      counter = counter % limit;
      var shouldSample = counter === 0;
      counter++;
      return shouldSample;
    };

    counting.toString = function () {
      return "countingSampler: sampleRate=".concat(sampleRate);
    };

    return counting;
  }
}

var CountingSampler =
/*#__PURE__*/
function (_Sampler) {
  _inherits(CountingSampler, _Sampler);

  function CountingSampler() {
    var sampleRate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    _classCallCheck(this, CountingSampler);

    return _possibleConstructorReturn(this, _getPrototypeOf(CountingSampler).call(this, makeCountingEvaluator(sampleRate < 1 ? sampleRate : 1)));
  }

  return CountingSampler;
}(Sampler);

var sampler = {
  Sampler: Sampler,
  CountingSampler: CountingSampler,
  neverSample: neverSample,
  alwaysSample: alwaysSample
};

var Record =
/*#__PURE__*/
function () {
  function Record(_ref) {
    var traceId = _ref.traceId,
        timestamp = _ref.timestamp,
        annotation = _ref.annotation;

    _classCallCheck(this, Record);

    this.traceId = traceId;
    this.timestamp = timestamp;
    this.annotation = annotation;
  }

  _createClass(Record, [{
    key: "toString",
    value: function toString() {
      return "Record(traceId=".concat(this.traceId.toString(), ", annotation=").concat(this.annotation.toString(), ")");
    }
  }]);

  return Record;
}();

var record = Record;

var Some$2 = option.Some,
    None$1 = option.None,
    verifyIsOptional$1 = option.verifyIsOptional,
    verifyIsNotOptional$1 = option.verifyIsNotOptional;

var TraceId =
/*#__PURE__*/
function () {
  function TraceId(params) {
    _classCallCheck(this, TraceId);

    var _params$traceId = params.traceId,
        traceId = _params$traceId === void 0 ? None$1 : _params$traceId,
        _params$parentId = params.parentId,
        parentId = _params$parentId === void 0 ? None$1 : _params$parentId,
        spanId = params.spanId,
        _params$sampled = params.sampled,
        sampled = _params$sampled === void 0 ? None$1 : _params$sampled,
        _params$flags = params.flags,
        flags = _params$flags === void 0 ? 0 : _params$flags;
    verifyIsOptional$1(traceId);
    verifyIsOptional$1(parentId);
    verifyIsNotOptional$1(spanId);
    verifyIsOptional$1(sampled);
    this._traceId = traceId;
    this._parentId = parentId;
    this._spanId = spanId;
    this._sampled = sampled;
    this._flags = flags;
  }

  _createClass(TraceId, [{
    key: "isDebug",
    value: function isDebug() {
      // The jshint tool always complains about using bitwise operators,
      // but in this case it's actually intentional, so we disable the warning:
      // jshint bitwise: false
      return (this._flags & 1) === 1;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "TraceId(spanId=".concat(this.spanId.toString()) + ", parentId=".concat(this.parentId.toString()) + ", traceId=".concat(this.traceId.toString(), ")");
    }
  }, {
    key: "spanId",
    get: function get() {
      return this._spanId;
    }
  }, {
    key: "parentId",
    get: function get() {
      return this._parentId.getOrElse(this.spanId);
    }
  }, {
    key: "traceId",
    get: function get() {
      return this._traceId.getOrElse(this.parentId);
    }
  }, {
    key: "sampled",
    get: function get() {
      return this.isDebug() ? new Some$2(true) : this._sampled;
    }
  }, {
    key: "flags",
    get: function get() {
      return this._flags;
    }
  }]);

  return TraceId;
}();

var TraceId_1 = TraceId;

// === Generate a random 64-bit number in fixed-length hex format
function randomTraceId() {
  var digits = '0123456789abcdef';
  var n = '';

  for (var i = 0; i < 16; i++) {
    var rand = Math.floor(Math.random() * 16);
    n += digits[rand];
  }

  return n;
}

var randomTraceId_1 = randomTraceId;

var hrTimeSupport = typeof process !== 'undefined' && process.hrtime; // since hrtime isn't available, we can ignore the input parameters

function nowLegacy() {
  return Date.now() * 1000;
}

function nowHrTime(startTimestamp, startTick) {
  if (startTimestamp && startTick) {
    var _hrtime = process.hrtime(startTick);

    var elapsedMicros = Math.floor(_hrtime[0] * 1000000 + _hrtime[1] / 1000);
    return startTimestamp + elapsedMicros;
  } else {
    return Date.now() * 1000;
  }
} // Returns the current time in epoch microseconds
// if startTimestamp and startTick are present, process.hrtime is used
// See https://nodejs.org/api/process.html#process_process_hrtime_time


var now = hrTimeSupport ? nowHrTime : nowLegacy;
var hrtime = hrTimeSupport ? function () {
  return process.hrtime();
} : function () {
  return undefined;
};
var time = {
  now: now,
  hrtime: hrtime
};

function Endpoint(_ref) {
  var serviceName = _ref.serviceName,
      ipv4 = _ref.ipv4,
      port = _ref.port;
  this.setServiceName(serviceName);
  this.setIpv4(ipv4);
  this.setPort(port);
}

Endpoint.prototype.setServiceName = function setServiceName(serviceName) {
  // In zipkin, names are lowercase. This eagerly converts to alert users early.
  this.serviceName = serviceName ? serviceName.toLocaleLowerCase() : undefined;
};

Endpoint.prototype.setIpv4 = function setIpv4(ipv4) {
  this.ipv4 = ipv4;
};

Endpoint.prototype.setPort = function setPort(port) {
  this.port = port || undefined;
};

Endpoint.prototype.isEmpty = function isEmpty() {
  return this.serviceName === undefined && this.ipv4 === undefined && this.port === undefined;
};

function Annotation(timestamp, value) {
  this.timestamp = timestamp;
  this.value = value.toString();
}

Annotation.prototype.toString = function toString() {
  return "Annotation(value=\"".concat(this.value, "\")");
};

function Span(traceId) {
  var _this = this;

  this.traceId = traceId.traceId;

  traceId._parentId.ifPresent(function (id) {
    _this.parentId = id;
  });

  this.id = traceId.spanId;
  this.name = undefined; // no default

  this.kind = undefined; // no default

  this.timestamp = undefined;
  this.duration = undefined;
  this.localEndpoint = undefined; // no default

  this.remoteEndpoint = undefined; // no default

  this.annotations = [];
  this.tags = {};
  this.debug = traceId.isDebug();
  this.shared = false;
}

Span.prototype.setName = function setName(name) {
  // In zipkin, names are lowercase. This eagerly converts to alert users early.
  this.name = name ? name.toLocaleLowerCase() : undefined;
};

Span.prototype.setKind = function setKind(kind) {
  this.kind = kind;
};

Span.prototype.setTimestamp = function setTimestamp(timestamp) {
  this.timestamp = timestamp;
};

Span.prototype.setDuration = function setDuration(duration) {
  // Due to rounding errors, a fraction ends up as zero, so check undefined
  if (typeof duration !== 'undefined') {
    this.duration = Math.max(duration, 1);
  }
};

Span.prototype.setLocalEndpoint = function setLocalEndpoint(ep) {
  if (ep && !ep.isEmpty()) {
    this.localEndpoint = ep;
  } else {
    this.localEndpoint = undefined;
  }
};

Span.prototype.setRemoteEndpoint = function setRemoteEndpoint(ep) {
  if (ep && !ep.isEmpty()) {
    this.remoteEndpoint = ep;
  } else {
    this.remoteEndpoint = undefined;
  }
};

Span.prototype.addAnnotation = function addAnnotation(timestamp, value) {
  this.annotations.push(new Annotation(timestamp, value));
};

Span.prototype.putTag = function putTag(key, value) {
  this.tags[key] = value.toString();
};

Span.prototype.setDebug = function setDebug(debug) {
  this.debug = debug;
};

Span.prototype.setShared = function setShared(shared) {
  this.shared = shared;
};

Span.prototype.toString = function toString() {
  var annotations = this.annotations.map(function (a) {
    return a.toString();
  }).join(', ');
  return "Span(id=".concat(this.traceId, ", annotations=[").concat(annotations, "])");
};

var Endpoint_1 = Endpoint;
var Span_1 = Span;
var model = {
  Endpoint: Endpoint_1,
  Span: Span_1
};

var isPromise_1 = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

var None$2 = option.None,
    Some$3 = option.Some,
    fromNullable$1 = option.fromNullable;
var Sampler$1 = sampler.Sampler,
    alwaysSample$1 = sampler.alwaysSample;
var now$1 = time.now,
    hrtime$1 = time.hrtime;
var Endpoint$1 = model.Endpoint;

function requiredArg(name) {
  throw new Error("Tracer: Missing required argument ".concat(name, "."));
}

var Tracer =
/*#__PURE__*/
function () {
  function Tracer(_ref) {
    var _ref$ctxImpl = _ref.ctxImpl,
        ctxImpl = _ref$ctxImpl === void 0 ? requiredArg('ctxImpl') : _ref$ctxImpl,
        _ref$recorder = _ref.recorder,
        recorder = _ref$recorder === void 0 ? requiredArg('recorder') : _ref$recorder,
        _ref$sampler = _ref.sampler,
        sampler$$1 = _ref$sampler === void 0 ? new Sampler$1(alwaysSample$1) : _ref$sampler,
        _ref$traceId128Bit = _ref.traceId128Bit,
        traceId128Bit = _ref$traceId128Bit === void 0 ? false : _ref$traceId128Bit,
        _ref$supportsJoin = _ref.supportsJoin,
        supportsJoin = _ref$supportsJoin === void 0 ? true : _ref$supportsJoin,
        localServiceName = _ref.localServiceName,
        localEndpoint = _ref.localEndpoint,
        _ref$log = _ref.log,
        log = _ref$log === void 0 ? console : _ref$log,
        defaultTags = _ref.defaultTags;

    _classCallCheck(this, Tracer);

    this.log = log;
    this.recorder = recorder;
    this.sampler = sampler$$1;
    this.traceId128Bit = traceId128Bit;
    this.supportsJoin = supportsJoin;

    if (localEndpoint) {
      this._localEndpoint = localEndpoint;
    } else {
      this._localEndpoint = new Endpoint$1({
        serviceName: localServiceName || 'unknown'
      });
    }

    this._ctxImpl = ctxImpl;
    this._defaultTraceId = this.createRootId();
    this._startTimestamp = now$1();
    this._startTick = hrtime$1();

    if (defaultTags) {
      this.setTags(defaultTags);
    }
  }

  _createClass(Tracer, [{
    key: "scoped",
    value: function scoped(callback) {
      return this._ctxImpl.scoped(callback);
    }
  }, {
    key: "letId",
    value: function letId(id, callback) {
      return this._ctxImpl.letContext(id, callback);
    }
  }, {
    key: "createRootId",
    value: function createRootId() {
      var isSampled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : None$2;
      var isDebug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rootSpanId = randomTraceId_1();
      var traceId = this.traceId128Bit ? new Some$3(randomTraceId_1() + rootSpanId) : None$2;
      var id = new TraceId_1({
        traceId: traceId,
        parentId: None$2,
        spanId: rootSpanId,
        sampled: isSampled,
        flags: isDebug ? 1 : 0
      });

      if (isSampled === None$2) {
        id._sampled = this.sampler.shouldSample(id);
      }

      return id;
    }
  }, {
    key: "createChildId",
    value: function createChildId() {
      var currentId = fromNullable$1(this._ctxImpl.getContext());
      var childId = new TraceId_1({
        traceId: currentId.map(function (id) {
          return id.traceId;
        }),
        parentId: currentId.map(function (id) {
          return id.spanId;
        }),
        spanId: randomTraceId_1(),
        sampled: currentId.flatMap(function (id) {
          return id.sampled;
        }),
        flags: currentId.map(function (id) {
          return id.flags;
        }).getOrElse(0)
      });

      if (childId.sampled.present === false) {
        childId._sampled = this.sampler.shouldSample(childId);
      }

      return childId;
    } // creates a span, timing the given callable, adding any error as a tag
    // if the callable returns a promise, a span stops after the promise resolves

  }, {
    key: "local",
    value: function local(operationName, callable) {
      var _this = this;

      if (typeof callable !== 'function') {
        throw new Error('you must pass a function');
      }

      return this.scoped(function () {
        var traceId = _this.createChildId();

        _this.setId(traceId);

        _this.recordServiceName(_this._localEndpoint.serviceName);

        _this.recordAnnotation(new annotation_1.LocalOperationStart(operationName));

        var result;

        try {
          result = callable();
        } catch (err) {
          _this.recordBinary('error', err.message ? err.message : err.toString());

          _this.recordAnnotation(new annotation_1.LocalOperationStop());

          throw err;
        } // Finish the span on a synchronous success


        if (!isPromise_1(result)) {
          _this.recordAnnotation(new annotation_1.LocalOperationStop());

          return result;
        }

        if (!traceId.sampled.getOrElse(false)) {
          return result; // no need to stop as it was never started
        } // At this point we know we are sampled. Explicitly record against the ID


        var explicitRecord = function explicitRecord(annotation) {
          return _this.recorder.record(new record({
            traceId: traceId,
            timestamp: now$1(_this._startTimestamp, _this._startTick),
            annotation: annotation
          }));
        }; // Ensure the span representing the promise completes


        return result.then(function (output) {
          explicitRecord(new annotation_1.LocalOperationStop());
          return output;
        }).catch(function (err) {
          var message = err.message ? err.message : err.toString();
          explicitRecord(new annotation_1.BinaryAnnotation('error', message));
          explicitRecord(new annotation_1.LocalOperationStop());
          throw err;
        });
      });
    }
  }, {
    key: "setId",
    value: function setId(traceId) {
      this._ctxImpl.setContext(traceId);
    }
  }, {
    key: "recordAnnotation",
    value: function recordAnnotation(annotation) {
      var _this2 = this;

      var timestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : now$1(this._startTimestamp, this._startTick);
      this.id.sampled.ifPresent(function (sampled) {
        if (!sampled) return;

        _this2.recorder.record(new record({
          traceId: _this2.id,
          timestamp: timestamp,
          annotation: annotation
        }));
      });
    }
  }, {
    key: "recordMessage",
    value: function recordMessage(message) {
      this.recordAnnotation(new annotation_1.Message(message));
    }
  }, {
    key: "recordServiceName",
    value: function recordServiceName(serviceName) {
      this.recordAnnotation(new annotation_1.ServiceName(serviceName));
    }
  }, {
    key: "recordRpc",
    value: function recordRpc(name) {
      this.recordAnnotation(new annotation_1.Rpc(name));
    }
  }, {
    key: "recordClientAddr",
    value: function recordClientAddr(ia) {
      this.recordAnnotation(new annotation_1.ClientAddr(ia));
    }
  }, {
    key: "recordServerAddr",
    value: function recordServerAddr(ia) {
      this.recordAnnotation(new annotation_1.ServerAddr(ia));
    }
  }, {
    key: "recordLocalAddr",
    value: function recordLocalAddr(ia) {
      this.recordAnnotation(new annotation_1.LocalAddr(ia));
    }
  }, {
    key: "recordBinary",
    value: function recordBinary(key, value) {
      this.recordAnnotation(new annotation_1.BinaryAnnotation(key, value));
    }
  }, {
    key: "writeIdToConsole",
    value: function writeIdToConsole(message) {
      this.log.info("".concat(message, ": ").concat(this.id.toString()));
    }
  }, {
    key: "setTags",
    value: function setTags() {
      var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // eslint-disable-next-line no-restricted-syntax
      for (var tag in tags) {
        if (tags.hasOwnProperty(tag)) {
          this.recordBinary(tag, tags[tag]);
        }
      }
    }
  }, {
    key: "id",
    get: function get() {
      return this._ctxImpl.getContext() || this._defaultTraceId;
    }
  }, {
    key: "localEndpoint",
    get: function get() {
      return this._localEndpoint;
    }
  }]);

  return Tracer;
}();

var tracer = Tracer;

var explicitContext =
/*#__PURE__*/
function () {
  function ExplicitContext() {
    _classCallCheck(this, ExplicitContext);

    this.currentCtx = null;
  }

  _createClass(ExplicitContext, [{
    key: "setContext",
    value: function setContext(ctx) {
      this.currentCtx = ctx;
    }
  }, {
    key: "getContext",
    value: function getContext() {
      return this.currentCtx;
    }
  }, {
    key: "scoped",
    value: function scoped(callable) {
      var prevCtx = this.currentCtx;
      var result = callable();
      this.currentCtx = prevCtx;
      return result;
    }
  }, {
    key: "letContext",
    value: function letContext(ctx, callable) {
      var _this = this;

      return this.scoped(function () {
        _this.setContext(ctx);

        return callable();
      });
    }
  }]);

  return ExplicitContext;
}();

var noop = function createNoopTracer() {
  var recorder = {
    record: function record() {}
  };
  var ctxImpl = new explicitContext();
  return new tracer({
    recorder: recorder,
    ctxImpl: ctxImpl
  });
};

var httpHeaders = {
  TraceId: 'X-B3-TraceId',
  SpanId: 'X-B3-SpanId',
  ParentSpanId: 'X-B3-ParentSpanId',
  Sampled: 'X-B3-Sampled',
  Flags: 'X-B3-Flags'
};

var now$2 = time.now,
    hrtime$2 = time.hrtime;
var Span$1 = model.Span,
    Endpoint$2 = model.Endpoint;

function PartialSpan(traceId) {
  this.traceId = traceId;
  this.startTimestamp = now$2();
  this.startTick = hrtime$2();
  this.delegate = new Span$1(traceId);
  this.localEndpoint = new Endpoint$2({});
}

PartialSpan.prototype.finish = function finish() {
  if (this.endTimestamp) {
    return;
  }

  this.endTimestamp = now$2(this.startTimestamp, this.startTick);
};

var BatchRecorder =
/*#__PURE__*/
function () {
  function BatchRecorder(_ref) {
    var _this = this;

    var logger = _ref.logger,
        _ref$timeout = _ref.timeout,
        timeout = _ref$timeout === void 0 ? 60 * 1000000 : _ref$timeout;

    _classCallCheck(this, BatchRecorder);

    this.logger = logger;
    this.timeout = timeout;
    this.partialSpans = new Map(); // read through the partials spans regularly
    // and collect any timed-out ones

    var timer = setInterval(function () {
      _this.partialSpans.forEach(function (span, id) {
        if (_this._timedOut(span)) {
          _this._writeSpan(id);
        }
      });
    }, 1000);

    if (timer.unref) {
      // unref might not be available in browsers
      timer.unref(); // Allows Node to terminate instead of blocking on timer
    }
  }

  _createClass(BatchRecorder, [{
    key: "_writeSpan",
    value: function _writeSpan(id) {
      var span = this.partialSpans.get(id); // TODO(adriancole) refactor so this responsibility isn't in writeSpan

      if (span === undefined) {
        // Span not found.  Could have been expired.
        return;
      } // ready for garbage collection


      this.partialSpans.delete(id);
      var spanToWrite = span.delegate;
      spanToWrite.setLocalEndpoint(span.localEndpoint);

      if (span.endTimestamp) {
        spanToWrite.setTimestamp(span.startTimestamp);
        spanToWrite.setDuration(span.endTimestamp - span.startTimestamp);
      }

      this.logger.logSpan(spanToWrite);
    }
  }, {
    key: "_updateSpanMap",
    value: function _updateSpanMap(id, updater) {
      var span;

      if (this.partialSpans.has(id)) {
        span = this.partialSpans.get(id);
      } else {
        span = new PartialSpan(id);
      }

      updater(span);

      if (span.endTimestamp) {
        this._writeSpan(id);
      } else {
        this.partialSpans.set(id, span);
      }
    }
  }, {
    key: "_timedOut",
    value: function _timedOut(span) {
      return span.startTimestamp + this.timeout < now$2();
    }
  }, {
    key: "record",
    value: function record(rec) {
      var id = rec.traceId;

      this._updateSpanMap(id, function (span) {
        switch (rec.annotation.annotationType) {
          case 'ClientSend':
            span.delegate.setKind('CLIENT');
            break;

          case 'ClientRecv':
            span.finish();
            span.delegate.setKind('CLIENT');
            break;

          case 'ServerSend':
            span.finish();
            span.delegate.setKind('SERVER');
            break;

          case 'ServerRecv':
            // TODO: only set this to false when we know we in an existing trace
            span.delegate.setShared(id.parentId !== id.spanId);
            span.delegate.setKind('CLIENT');
            break;

          case 'ProducerStart':
            span.delegate.setKind('PRODUCER');
            break;

          case 'ProducerStop':
            span.finish();
            span.delegate.setKind('PRODUCER');
            break;

          case 'ConsumerStart':
            span.delegate.setKind('CONSUMER');
            break;

          case 'ConsumerStop':
            span.finish();
            span.delegate.setKind('CONSUMER');
            break;

          case 'MessageAddr':
            span.delegate.setRemoteEndpoint(new Endpoint$2({
              serviceName: rec.annotation.serviceName,
              ipv4: rec.annotation.host && rec.annotation.host.ipv4(),
              port: rec.annotation.port
            }));
            break;

          case 'LocalOperationStart':
            span.delegate.setName(rec.annotation.name);
            break;

          case 'LocalOperationStop':
            span.finish();
            break;

          case 'Message':
            span.delegate.addAnnotation(rec.timestamp, rec.annotation.message);
            break;

          case 'Rpc':
            span.delegate.setName(rec.annotation.name);
            break;

          case 'ServiceName':
            span.localEndpoint.setServiceName(rec.annotation.serviceName);
            break;

          case 'BinaryAnnotation':
            span.delegate.putTag(rec.annotation.key, rec.annotation.value);
            break;

          case 'LocalAddr':
            span.localEndpoint.setIpv4(rec.annotation.host && rec.annotation.host.ipv4());
            span.localEndpoint.setPort(rec.annotation.port);
            break;

          case 'ServerAddr':
            span.delegate.setKind('CLIENT');
            span.delegate.setRemoteEndpoint(new Endpoint$2({
              serviceName: rec.annotation.serviceName,
              ipv4: rec.annotation.host && rec.annotation.host.ipv4(),
              port: rec.annotation.port
            }));
            break;

          default:
            break;
        }
      });
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'BatchRecorder()';
    }
  }]);

  return BatchRecorder;
}();

var batchRecorder = BatchRecorder;

var ConsoleRecorder =
/*#__PURE__*/
function () {
  /* eslint-disable no-console */
  function ConsoleRecorder() {
    var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : console.log;

    _classCallCheck(this, ConsoleRecorder);

    this.logger = logger;
  }

  _createClass(ConsoleRecorder, [{
    key: "record",
    value: function record(rec) {
      var id = rec.traceId;
      this.logger("Record at (spanId=".concat(id.spanId, ", parentId=").concat(id.parentId, ",") + " traceId=".concat(id.traceId, "): ").concat(rec.annotation.toString()));
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'consoleTracer';
    }
  }]);

  return ConsoleRecorder;
}();

var consoleRecorder = ConsoleRecorder;

function parseRequestUrl(requestUrl) {
  var parsed = url.parse(requestUrl);
  return {
    host: parsed.hostname,
    path: parsed.pathname
  };
}

var parseUrl = parseRequestUrl;

var Some$4 = option.Some,
    None$3 = option.None;

function stringToBoolean(str) {
  return str === '1' || str === 'true';
}

function stringToIntOption(str) {
  try {
    return new Some$4(parseInt(str));
  } catch (err) {
    return None$3;
  }
}

function containsRequiredHeaders(readHeader) {
  return readHeader(httpHeaders.TraceId) !== None$3 && readHeader(httpHeaders.SpanId) !== None$3;
}

function requiredArg$1(name) {
  throw new Error("HttpServerInstrumentation: Missing required argument ".concat(name, "."));
}

var HttpServerInstrumentation =
/*#__PURE__*/
function () {
  function HttpServerInstrumentation(_ref) {
    var _ref$tracer = _ref.tracer,
        tracer = _ref$tracer === void 0 ? requiredArg$1('tracer') : _ref$tracer,
        _ref$serviceName = _ref.serviceName,
        serviceName = _ref$serviceName === void 0 ? tracer.localEndpoint.serviceName : _ref$serviceName,
        host = _ref.host,
        _ref$port = _ref.port,
        port = _ref$port === void 0 ? requiredArg$1('port') : _ref$port;

    _classCallCheck(this, HttpServerInstrumentation);

    this.tracer = tracer;
    this.serviceName = serviceName;
    this.host = host && new InetAddress_1(host);
    this.port = port;
  }

  _createClass(HttpServerInstrumentation, [{
    key: "_createIdFromHeaders",
    value: function _createIdFromHeaders(readHeader) {
      var _this = this;

      if (containsRequiredHeaders(readHeader)) {
        var spanId = readHeader(httpHeaders.SpanId);
        var parentId = spanId.map(function (sid) {
          var traceId = readHeader(httpHeaders.TraceId);
          var parentSpanId = readHeader(httpHeaders.ParentSpanId);
          var sampled = readHeader(httpHeaders.Sampled);
          var flags = readHeader(httpHeaders.Flags).flatMap(stringToIntOption).getOrElse(0);
          return new TraceId_1({
            traceId: traceId,
            parentId: parentSpanId,
            spanId: sid,
            sampled: sampled.map(stringToBoolean),
            flags: flags
          });
        });
        return !this.tracer.supportsJoin ? parentId.map(function (id) {
          return _this.tracer.letId(id, function () {
            return _this.tracer.createChildId();
          });
        }) : parentId;
      } else {
        if (readHeader(httpHeaders.Flags) !== None$3 || readHeader(httpHeaders.Sampled) !== None$3) {
          var sampled = readHeader(httpHeaders.Sampled) === None$3 ? None$3 : readHeader(httpHeaders.Sampled).map(stringToBoolean);
          var flags = readHeader(httpHeaders.Flags).flatMap(stringToIntOption).getOrElse(0);
          return new Some$4(this.tracer.createRootId(sampled, flags === 1));
        } else {
          return new Some$4(this.tracer.createRootId());
        }
      }
    }
  }, {
    key: "recordRequest",
    value: function recordRequest(method, requestUrl, readHeader) {
      var _this2 = this;

      this._createIdFromHeaders(readHeader).ifPresent(function (id) {
        return _this2.tracer.setId(id);
      });

      var id = this.tracer.id;

      var _parseRequestUrl = parseUrl(requestUrl),
          path = _parseRequestUrl.path;

      this.tracer.recordServiceName(this.serviceName);
      this.tracer.recordRpc(method.toUpperCase());
      this.tracer.recordBinary('http.path', path);
      this.tracer.recordAnnotation(new annotation_1.ServerRecv());
      this.tracer.recordAnnotation(new annotation_1.LocalAddr({
        host: this.host,
        port: this.port
      }));
      return id;
    }
  }, {
    key: "recordResponse",
    value: function recordResponse(id, statusCode, error) {
      this.tracer.setId(id);
      this.tracer.recordBinary('http.status_code', statusCode.toString());

      if (error) {
        this.tracer.recordBinary('error', error.toString());
      } else if (statusCode < 200 || statusCode > 399) {
        this.tracer.recordBinary('error', statusCode.toString());
      }

      this.tracer.recordAnnotation(new annotation_1.ServerSend());
    }
  }]);

  return HttpServerInstrumentation;
}();

var httpServer = HttpServerInstrumentation;

function appendZipkinHeaders(req, traceId) {
  var headers = req.headers || {};
  headers[httpHeaders.TraceId] = traceId.traceId;
  headers[httpHeaders.SpanId] = traceId.spanId;

  traceId._parentId.ifPresent(function (psid) {
    headers[httpHeaders.ParentSpanId] = psid;
  });

  traceId.sampled.ifPresent(function (sampled) {
    headers[httpHeaders.Sampled] = sampled ? '1' : '0';
  });

  if (traceId.isDebug()) {
    headers[httpHeaders.Flags] = '1';
  }

  return headers;
}

function addZipkinHeaders(req, traceId) {
  var headers = appendZipkinHeaders(req, traceId);
  return Object.assign({}, req, {
    headers: headers
  });
}

var request = {
  addZipkinHeaders: addZipkinHeaders
};

function requiredArg$2(name) {
  throw new Error("HttpClientInstrumentation: Missing required argument ".concat(name, "."));
}

var HttpClientInstrumentation =
/*#__PURE__*/
function () {
  function HttpClientInstrumentation(_ref) {
    var _ref$tracer = _ref.tracer,
        tracer = _ref$tracer === void 0 ? requiredArg$2('tracer') : _ref$tracer,
        _ref$serviceName = _ref.serviceName,
        serviceName = _ref$serviceName === void 0 ? tracer.localEndpoint.serviceName : _ref$serviceName,
        remoteServiceName = _ref.remoteServiceName;

    _classCallCheck(this, HttpClientInstrumentation);

    this.tracer = tracer;
    this.serviceName = serviceName;
    this.remoteServiceName = remoteServiceName;
  }

  _createClass(HttpClientInstrumentation, [{
    key: "recordRequest",
    value: function recordRequest(request$$1, url$$1, method) {
      this.tracer.setId(this.tracer.createChildId());
      var traceId = this.tracer.id;

      var _parseRequestUrl = parseUrl(url$$1),
          path = _parseRequestUrl.path;

      this.tracer.recordServiceName(this.serviceName);
      this.tracer.recordRpc(method.toUpperCase());
      this.tracer.recordBinary('http.path', path);
      this.tracer.recordAnnotation(new annotation_1.ClientSend());

      if (this.remoteServiceName) {
        // TODO: can we get the host and port of the http connection?
        this.tracer.recordAnnotation(new annotation_1.ServerAddr({
          serviceName: this.remoteServiceName
        }));
      }

      return request.addZipkinHeaders(request$$1, traceId);
    }
  }, {
    key: "recordResponse",
    value: function recordResponse(traceId, statusCode) {
      this.tracer.setId(traceId);
      this.tracer.recordBinary('http.status_code', statusCode.toString());

      if (statusCode < 200 || statusCode > 399) {
        this.tracer.recordBinary('error', statusCode.toString());
      }

      this.tracer.recordAnnotation(new annotation_1.ClientRecv());
    }
  }, {
    key: "recordError",
    value: function recordError(traceId, error) {
      this.tracer.setId(traceId);
      this.tracer.recordBinary('error', error.toString());
      this.tracer.recordAnnotation(new annotation_1.ClientRecv());
    }
  }]);

  return HttpClientInstrumentation;
}();

var httpClient = HttpClientInstrumentation;

var instrumentation = {
  HttpServer: httpServer,
  HttpClient: httpClient
};

function toV1Endpoint(endpoint) {
  if (endpoint === undefined) {
    return undefined;
  }

  var res = {
    serviceName: endpoint.serviceName || '' // undefined is not allowed in v1

  };

  if (endpoint.ipv4) {
    res.ipv4 = endpoint.ipv4;
  }

  if (endpoint.port) {
    res.port = endpoint.port;
  }

  return res;
}

function toV1Annotation(ann, endpoint) {
  return {
    value: ann.value,
    timestamp: ann.timestamp,
    endpoint: endpoint
  };
}

function encodeV1(span) {
  var res = {
    traceId: span.traceId
  };

  if (span.parentId) {
    // instead of writing "parentId": NULL
    res.parentId = span.parentId;
  }

  res.id = span.id;
  res.name = span.name || ''; // undefined is not allowed in v1
  // Log timestamp and duration if this tracer started and completed this span.

  if (!span.shared) {
    res.timestamp = span.timestamp;
    res.duration = span.duration;
  }

  var jsonEndpoint = toV1Endpoint(span.localEndpoint);
  var beginAnnotation;
  var endAnnotation;
  var addressKey;

  switch (span.kind) {
    case 'CLIENT':
      beginAnnotation = span.timestamp ? 'cs' : undefined;
      endAnnotation = 'cr';
      addressKey = 'sa';
      break;

    case 'SERVER':
      beginAnnotation = span.timestamp ? 'sr' : undefined;
      endAnnotation = 'ss';
      addressKey = 'ca';
      break;

    case 'PRODUCER':
      beginAnnotation = span.timestamp ? 'ms' : undefined;
      endAnnotation = 'ws';
      addressKey = 'ma';
      break;

    case 'CONSUMER':
      if (span.timestamp && span.duration) {
        beginAnnotation = 'wr';
        endAnnotation = 'mr';
      } else if (span.timestamp) {
        beginAnnotation = 'mr';
      }

      addressKey = 'ma';
      break;

    default:
  }

  if (span.annotations.length > 0 || beginAnnotation) {
    // don't write empty array
    res.annotations = span.annotations.map(function (ann) {
      return toV1Annotation(ann, jsonEndpoint);
    });
  }

  if (beginAnnotation) {
    res.annotations.push({
      value: beginAnnotation,
      timestamp: span.timestamp,
      endpoint: jsonEndpoint
    });

    if (span.duration) {
      res.annotations.push({
        value: endAnnotation,
        timestamp: span.timestamp + span.duration,
        endpoint: jsonEndpoint
      });
    }
  }

  var keys = Object.keys(span.tags);

  if (keys.length > 0 || span.remoteEndpoint) {
    // don't write empty array
    res.binaryAnnotations = keys.map(function (key) {
      return {
        key: key,
        value: span.tags[key],
        endpoint: jsonEndpoint
      };
    });
  }

  if (span.remoteEndpoint) {
    var address = {
      key: addressKey,
      value: true,
      endpoint: toV1Endpoint(span.remoteEndpoint)
    };
    res.binaryAnnotations.push(address);
  }

  if (span.debug) {
    // instead of writing "debug": false
    res.debug = true;
  }

  return JSON.stringify(res);
}

function encodeV2(span) {
  var copy = {
    traceId: span.traceId
  };

  if (span.parentId) {
    copy.parentId = span.parentId;
  }

  copy.id = span.id;

  if (span.name) {
    copy.name = span.name;
  }

  if (span.kind) {
    copy.kind = span.kind;
  }

  if (span.timestamp) {
    copy.timestamp = span.timestamp;
  }

  if (span.duration) {
    copy.duration = span.duration;
  }

  if (span.localEndpoint) {
    copy.localEndpoint = span.localEndpoint;
  }

  if (span.remoteEndpoint) {
    copy.remoteEndpoint = span.remoteEndpoint;
  }

  if (span.annotations.length > 0) {
    copy.annotations = span.annotations;
  }

  if (Object.keys(span.tags).length > 0) {
    copy.tags = span.tags;
  }

  if (span.debug) {
    copy.debug = true;
  }

  if (span.shared) {
    copy.shared = true;
  }

  return JSON.stringify(copy);
}

var JSON_V1 = {
  encode: function encode(span) {
    return encodeV1(span);
  }
};
var JSON_V2 = {
  encode: function encode(span) {
    return encodeV2(span);
  }
};
var jsonEncoder = {
  JSON_V1: JSON_V1,
  JSON_V2: JSON_V2
};

module.exports = {
  Tracer: tracer,
  createNoopTracer: noop,
  randomTraceId: randomTraceId_1,
  TraceId: TraceId_1,
  option: option,
  Annotation: annotation_1,
  InetAddress: InetAddress_1,
  HttpHeaders: httpHeaders,
  BatchRecorder: batchRecorder,
  ConsoleRecorder: consoleRecorder,
  ExplicitContext: explicitContext,
  sampler: sampler,
  Request: request,
  Instrumentation: instrumentation,
  model: model,
  jsonEncoder: jsonEncoder,
  parseRequestUrl: parseUrl
};
